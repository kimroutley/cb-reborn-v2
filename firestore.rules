rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ── Helper Functions ──
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isValidGameData() {
      return request.resource.data.keys().hasAll(['phase', 'players', 'dayCount'])
        && request.resource.data.phase is string
        && request.resource.data.players is list
        && request.resource.data.dayCount is number;
    }
    
    function isValidJoinRequest() {
      return request.resource.data.keys().hasAll(['name', 'timestamp'])
        && request.resource.data.name is string
        && request.resource.data.name.size() > 0
        && request.resource.data.name.size() <= 50;
    }
    
    function isValidAction() {
      return request.resource.data.keys().hasAll(['type', 'stepId', 'playerId', 'timestamp'])
        && request.resource.data.type is string
        && request.resource.data.stepId is string
        && request.resource.data.playerId is string
        && (!request.resource.data.keys().hasAny(['targetId']) || request.resource.data.targetId is string)
        && (!request.resource.data.keys().hasAny(['payload']) || request.resource.data.payload is map);
    }

    function isGameHost(joinCode) {
      return get(/databases/$(database)/documents/games/$(joinCode)).data.hostId == request.auth.uid;
    }

    function ownsPlayer(joinCode, playerId) {
      return playerId == request.auth.uid
        || get(/databases/$(database)/documents/games/$(joinCode)/private_state/$(playerId)).data.uid == request.auth.uid;
    }

    function isRegisteredPlayer(joinCode, playerId) {
      return exists(/databases/$(database)/documents/games/$(joinCode)/private_state/$(playerId));
    }
    
    // ── Joins/Actions Verification ──
    function isPlayerOfGame(joinCode) {
      return exists(/databases/$(database)/documents/games/$(joinCode)/private_state/$(request.auth.uid)) 
        || isGameHost(joinCode);
    }

    // ── Games Collection ──
    match /games/{joinCode} {
      
      // Authenticated users can read the public game state.
      // Private role/alliance data remains protected under /private_state rules.
      allow read: if isAuthenticated();
      
      // Host can create/update/delete games
      // Split by operation to avoid ambiguous type checks on `resource`/`request.resource`.
      allow create: if isAuthenticated()
        && isValidGameData()
        && request.resource.data.hostId == request.auth.uid;

      allow update: if isAuthenticated()
        && resource.data.hostId == request.auth.uid
        && isValidGameData()
        && request.resource.data.hostId == resource.data.hostId;

      allow delete: if isAuthenticated()
        && resource.data.hostId == request.auth.uid;
      
      // ── Join Requests Subcollection ──
      match /joins/{joinId} {
        // Anyone can create a join request with valid data
        allow create: if isValidJoinRequest() && isAuthenticated()
          && get(/databases/$(database)/documents/games/$(joinCode)).data.phase == 'lobby'
          && request.resource.data.uid == request.auth.uid;
        
        // Host can read and delete join requests
        allow read, delete: if isAuthenticated() &&
           get(/databases/$(database)/documents/games/$(joinCode)).data.hostId == request.auth.uid;
        
        // No updates allowed (join requests are immutable)
        allow update: if false;
      }
      
      // ── Player Actions Subcollection ──
      match /actions/{actionId} {
        // Players can submit actions with valid data
        // Check that the sender is the player referenced and is currently in the game
        allow create: if isValidAction() && isAuthenticated() 
          && ownsPlayer(joinCode, request.resource.data.playerId)
          && isRegisteredPlayer(joinCode, request.resource.data.playerId);
        
        // Host can read actions
        allow read: if isAuthenticated() && isGameHost(joinCode);
        
        // No updates or deletes (actions are immutable history)
        allow update, delete: if false;
      }
      
      // ── Push Subscriptions (Web Push targeting) ──
      match /push_subscriptions/{playerId} {
        // Authenticated users can register/update their own push subscription
        allow create, update: if isAuthenticated()
          && (playerId == request.auth.uid || get(/databases/$(database)/documents/games/$(joinCode)).data.hostId == request.auth.uid)
          && request.resource.data.keys().hasAll(['endpoint', 'keys']);
        
        allow read: if isAuthenticated() && (
          playerId == request.auth.uid ||
          get(/databases/$(database)/documents/games/$(joinCode)).data.hostId == request.auth.uid
        );
        allow delete: if isAuthenticated() && (playerId == request.auth.uid);
      }
      
      // ── Private Player State Subcollection ──
      match /private_state/{playerId} {
        // Only authenticated host or the owning player can read private state
        allow read: if isAuthenticated() && (
          request.auth.uid == playerId ||
          resource.data.uid == request.auth.uid ||
          isGameHost(joinCode)
        );

        // Only authenticated host can write private state
        allow write: if isAuthenticated() &&
          isGameHost(joinCode);
      }
      
      // ── Chat Messages Subcollection ──
      match /chat/{messageId} {
        // Anyone in the game can read chat messages
        allow read: if isAuthenticated();
        
        // Anyone can create chat messages (players chatting)
        allow create: if isAuthenticated()
          && request.resource.data.keys().hasAll(['playerId', 'message', 'timestamp'])
          && request.resource.data.playerId is string
          && request.resource.data.playerId.size() > 0
          && request.resource.data.playerId != 'unknown'
          && ownsPlayer(joinCode, request.resource.data.playerId)
          && isRegisteredPlayer(joinCode, request.resource.data.playerId)
          && request.resource.data.message is string
          && request.resource.data.message.size() > 0
          && request.resource.data.message.size() <= 500;
        
        // No updates or deletes (chat is immutable)
        allow update, delete: if false;
      }
    }
    
    // ── Game Records Collection (completed games history) ──
    match /game_records/{recordId} {
      // Host can read their own game records
      allow read: if isAuthenticated();
      
      // Host can create game records
      allow create: if isAuthenticated()
        && request.resource.data.keys().hasAll(['winner', 'endedAt', 'playerCount']);
      
      // No updates or deletes (records are immutable)
      allow update, delete: if false;
    }
    
    // ── Games Night Records Collection ──
    match /games_nights/{nightId} {
      // Host can read their own games night records
      allow read: if isAuthenticated();
      
      // Host can create and update games night records
      allow create, update: if isAuthenticated()
        && request.resource.data.keys().hasAll(['startedAt', 'gameIds']);
      
      // Host can delete their own records
      allow delete: if isAuthenticated();
    }

    // ── User Profiles Collection (Moniker Gate) ──
    match /user_profiles/{uid} {
      // Users can read/write only their own profile document.
      allow read, create, update: if isAuthenticated() && request.auth.uid == uid;

      // Prevent client-side profile deletes.
      allow delete: if false;
    }
  }
}

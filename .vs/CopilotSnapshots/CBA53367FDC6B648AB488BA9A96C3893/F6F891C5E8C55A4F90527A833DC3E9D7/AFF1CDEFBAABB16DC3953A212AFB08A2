import 'package:cb_theme/cb_theme.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../player_destinations.dart';
import '../player_navigation.dart';
import '../active_bridge.dart';
import '../player_onboarding_provider.dart';
import 'connect_screen.dart';
import 'lobby_screen.dart';
import 'profile_screen.dart';
import 'claim_screen.dart';
import 'game_screen.dart';
import 'start_transition_screen.dart';
import 'guides_screen.dart';
import 'games_night_screen.dart';
import 'hall_of_fame_screen.dart';
import 'stats_screen.dart';
import 'about_screen.dart';
import 'settings_screen.dart';

class PlayerHomeShell extends ConsumerStatefulWidget {
  const PlayerHomeShell({
    super.key,
    this.startConfirmTimeout = const Duration(seconds: 10),
    this.transitionDuration = const Duration(milliseconds: 2200),
  });

  final Duration startConfirmTimeout;
  final Duration transitionDuration;

  @override
  ConsumerState<PlayerHomeShell> createState() => _PlayerHomeShellState();
}

class _PlayerHomeShellState extends ConsumerState<PlayerHomeShell> {
  bool _handlingSetupTransition = false;

  static const Set<PlayerDestination> _sessionBoundDestinations = {
    PlayerDestination.lobby,
    PlayerDestination.claim,
    PlayerDestination.transition,
    PlayerDestination.game,
  };

  @override
  void initState() {
    super.initState();
    ref.listenManual(activeBridgeProvider, _onBridgeChanged);
  }

  void _onBridgeChanged(ActiveBridge? previous, ActiveBridge next) {
    final nav = ref.read(playerNavigationProvider.notifier);
    final onboarding = ref.read(playerOnboardingProvider.notifier);

    final prevState = previous?.state;
    final prevPhase = prevState?.phase;
    final prevConnected = prevState?.isConnected ?? false;
    final prevJoinAccepted = prevState?.joinAccepted ?? false;

    final nextState = next.state;
    final nextPhase = nextState.phase;
    final nextConnected = nextState.isConnected;
    final nextJoinAccepted = nextState.joinAccepted;

    final hasBridgeSession = nextConnected || nextJoinAccepted;
    if (!hasBridgeSession) {
      _handlingSetupTransition = false;
      onboarding.reset();

      final currentDestination = ref.read(playerNavigationProvider);
      if (_sessionBoundDestinations.contains(currentDestination)) {
        nav.setDestination(PlayerDestination.connect);
      }
      return;
    }

    final connectedNow = !prevConnected && nextConnected;
    final acceptedNow = !prevJoinAccepted && nextJoinAccepted;
    final destination = ref.read(playerNavigationProvider);
    if ((connectedNow || acceptedNow) &&
        nextPhase == 'lobby' &&
        destination == PlayerDestination.connect) {
      nav.setDestination(PlayerDestination.lobby);
    }

    if (nextPhase == prevPhase) {
      return;
    }

    switch (nextPhase) {
      case 'lobby':
        _handlingSetupTransition = false;
        onboarding.setAwaitingStartConfirmation(false);
        nav.setDestination(PlayerDestination.lobby);
        break;
      case 'setup':
        if (_handlingSetupTransition) {
          return;
        }
        _handlingSetupTransition = true;
        onboarding.setAwaitingStartConfirmation(true);
        nav.setDestination(PlayerDestination.lobby);
        _showStartConfirmationDialog();
        break;
      case 'night':
      case 'day':
      case 'resolution':
      case 'endGame':
        _handlingSetupTransition = false;
        onboarding.setAwaitingStartConfirmation(false);
        nav.setDestination(PlayerDestination.game);
        break;
      default:
        break;
    }
  }

  void _showStartConfirmationDialog() {
    if (widget.startConfirmTimeout <= Duration.zero) {
      ref
          .read(playerOnboardingProvider.notifier)
          .setAwaitingStartConfirmation(false);
      _beginTransitionToGame();
      return;
    }

    WidgetsBinding.instance.addPostFrameCallback((_) async {
      if (!mounted) {
        return;
      }

      var dialogCompleted = false;
      final timeoutSeconds = widget.startConfirmTimeout.inSeconds;

      final dialogFuture = showThemedDialog<bool>(
        context: context,
        accentColor: Theme.of(context).colorScheme.secondary,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              'SESSION STARTING',
              style: Theme.of(context).textTheme.headlineSmall!.copyWith(
                    color: Theme.of(context).colorScheme.secondary,
                    fontWeight: FontWeight.w900,
                    letterSpacing: 1.5,
                    shadows: CBColors.textGlow(
                        Theme.of(context).colorScheme.secondary),
                  ),
            ),
            const SizedBox(height: 24),
            Text(
              'THE HOST HAS INITIATED THE SEQUENCE. CONNECT TO THE TERMINAL NOW.',
              textAlign: TextAlign.center,
              style: Theme.of(context).textTheme.bodyMedium!.copyWith(
                    color: Theme.of(context)
                        .colorScheme
                        .onSurface
                        .withValues(alpha: 0.8),
                    fontWeight: FontWeight.bold,
                  ),
            ),
            const SizedBox(height: 12),
            Text(
              'AUTO-UPLINK IN ${timeoutSeconds}S',
              style: Theme.of(context).textTheme.labelSmall!.copyWith(
                    color: Theme.of(context)
                        .colorScheme
                        .secondary
                        .withValues(alpha: 0.6),
                    letterSpacing: 1.2,
                  ),
            ),
            const SizedBox(height: 32),
            CBPrimaryButton(
              label: 'Enter The Club',
              backgroundColor: Theme.of(context)
                  .colorScheme
                  .secondary
                  .withValues(alpha: 0.2),
              foregroundColor: Theme.of(context).colorScheme.secondary,
              onPressed: () => Navigator.of(context).pop(true),
            ),
          ],
        ),
      ).then((value) {
        dialogCompleted = true;
        return value ?? false;
      });

      final autoJoinFuture = Future<bool>.delayed(
        widget.startConfirmTimeout,
        () => true,
      );

      final shouldJoin = await Future.any<bool>([
        dialogFuture,
        autoJoinFuture,
      ]);

      if (!mounted) {
        return;
      }

      if (!dialogCompleted) {
        Navigator.of(context, rootNavigator: true).pop(true);
      }

      ref
          .read(playerOnboardingProvider.notifier)
          .setAwaitingStartConfirmation(false);
      if (shouldJoin) {
        _beginTransitionToGame();
      } else {
        _handlingSetupTransition = false;
      }
    });
  }

  void _beginTransitionToGame() {
    if (!mounted) {
      return;
    }

    final nav = ref.read(playerNavigationProvider.notifier);
    nav.setDestination(PlayerDestination.transition);

    Future<void>.delayed(widget.transitionDuration, () {
      if (!mounted) {
        return;
      }
      nav.setDestination(PlayerDestination.game);
      _handlingSetupTransition = false;
    });
  }

  @override
  Widget build(BuildContext context) {
    final destination = ref.watch(playerNavigationProvider);

    Widget activeWidget;
    switch (destination) {
      case PlayerDestination.connect:
        activeWidget = const ConnectScreen();
        break;
      case PlayerDestination.lobby:
        activeWidget = const LobbyScreen();
        break;
      case PlayerDestination.claim:
        activeWidget = const ClaimScreen();
        break;
      case PlayerDestination.transition:
        activeWidget = const StartTransitionScreen();
        break;
      case PlayerDestination.game:
        activeWidget = const GameScreen();
        break;
      case PlayerDestination.guides:
        activeWidget = const GuidesScreen();
        break;
      case PlayerDestination.gamesNight:
        activeWidget = const GamesNightScreen();
        break;
      case PlayerDestination.hallOfFame:
        activeWidget = const HallOfFameScreen();
        break;
      case PlayerDestination.profile:
        activeWidget = const ProfileScreen();
        break;
      case PlayerDestination.stats:
        activeWidget = const StatsScreen();
        break;
      case PlayerDestination.about:
        activeWidget = const AboutScreen();
        break;
      case PlayerDestination.settings:
        activeWidget = const SettingsScreen();
        break;
    }

    return AnimatedSwitcher(
      duration: const Duration(milliseconds: 500),
      transitionBuilder: (Widget child, Animation<double> animation) {
        return FadeTransition(
          opacity: animation,
          child: SlideTransition(
            position: Tween<Offset>(
              begin: const Offset(0.05, 0),
              end: Offset.zero,
            ).animate(CurvedAnimation(
              parent: animation,
              curve: Curves.easeOutCubic,
            )),
            child: child,
          ),
        );
      },
      child: KeyedSubtree(
        key: ValueKey(destination),
        child: activeWidget,
      ),
    );
  }
}
